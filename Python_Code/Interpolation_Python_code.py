# -*- coding: utf-8 -*-
"""
Created on Thu Mar 14 23:48:26 2019

@author: marri
"""


import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import missingno as msno
from matplotlib import pyplot
from scipy import interpolate
from sklearn import preprocessing
from fancyimpute import  KNN
import scipy.interpolate as spi

# =============================================================================
# define filepath and load latest data
# =============================================================================
filepath2 = ''
financial = pd.read_excel(filepath2+'Final_Financial_Datav.xlsx', error_bad_lines=False, encoding="utf-8") #klopt.


# =============================================================================
# DUMMY VARAIBLES
# =============================================================================
list_emplo= list(financial[financial.Employees > 500.0].index)
financial['EmployeesOver500']= np.where(financial.index.isin(list_emplo), True, False)


list_emplo= list(financial[financial.Employees < 250.0].index)
financial['EmployeesUnder250']= np.where(financial.index.isin(list_emplo),True, False)

list_rev= list(financial[financial.Revenues < 31].Revenues)
financial['RevenuesUnder31']= np.where(financial.Revenues.isin(list_rev), True, False)

columns_lit=['EmployeesUnder250', 'EmployeesOver500', 'RevenuesUnder31' ]


    
# =============================================================================
# Normalise Data
# =============================================================================


normalise = ['Revenues',
       'Equity', 'TotalAssets', 'MarketCapital', 'RWA', 'NetIncome',
       'NumberofCustomer', 'Employees', 'Branches', 'LoansOfCustomers',
       'DepositsofCustomers', 'NumberofOnlineCustomer']
financial[normalise] = preprocessing.MinMaxScaler().fit_transform(financial[normalise])


 #=============================================================================
 #Convert customers to online customers
 #=============================================================================
file_path_online= ''
online_eu=pd.read_csv(file_path_online, sep=';')

for number, value in financial.NumberofCustomer.dropna().iteritems():
    for country in online_eu.GEO:

        if financial.loc[number, 'country'] == country:
            percentage = online_eu[online_eu.GEO==country].Value.item()/100
            new_value = value * percentage


# =============================================================================
# Assessing missing data
# =============================================================================

bank_size_indicators = ['Revenues',
       'Equity', 'TotalAssets', 'MarketCapital', 'NetIncome','RWA', 
       'NumberofCustomer', 'Employees', 'Branches', 'LoansOfCustomers',
       'DepositsofCustomers', 'NumberofOnlineCustomer']
#Coverage Matrix 
msno.matrix(financial[bank_size_indicators])  


# =============================================================================
#  Correlation: heatmap and pearson vvalue
# =============================================================================
bank_size_indicators = ['Revenues',
       'Equity', 'TotalAssets', 'MarketCapital', 'NetIncome',
       'NumberofCustomer', 'Employees', 'Branches', 'LoansOfCustomers',
       'DepositsofCustomers', 'NumberofOnlineCustomer']



correlation = financial[bank_size_indicators].corr() 

import numpy as np; np.random.seed(0)
import seaborn as sns; sns.set()
corr = financial[bank_size_indicators].corr() 
ax = sns.heatmap(corr, cmap="YlGnBu", annot=True, fmt="d")

#p-values of correlation

from scipy.stats import pearsonr

def calculate_pvalues(df):
    df = df.dropna()._get_numeric_data()
    dfcols = pd.DataFrame(columns=df.columns)
    pvalues = dfcols.transpose().join(dfcols, how='outer')
    for r in df.columns:
        for c in df.columns:
            pvalues[r][c] = round(pearsonr(df[r], df[c])[1], 4)
    return pvalues

p_values= calculate_pvalues(financial[bank_size_indicators])


#Start Interpolation

# =============================================================================
# REVENUES predicted by total assets
# =============================================================================
filegraph = ''
predictor = 'TotalAssets'
var = 'Revenues'

dat = financial[[var, predictor]].dropna(subset=[predictor])
dat= dat[dat[var].isnull()]
dat2=financial[[var, predictor ]].dropna(subset=[var, predictor])

y=np.array(dat2[var])
x= np.array(dat2[predictor])

f = interpolate.interp1d(x,y, kind='linear')

x_new= np.array(dat[predictor])
intfunc = spi.interp1d(x,y ,fill_value="extrapolate")
y_new = intfunc(x_new)

fig = pyplot.figure()
plt.scatter(x,y, color='darkblue', label='Data-Points')
plt.scatter(x_new,y_new, color='lightblue', label='Imputation-Points')
plt.xlabel(var)
plt.ylabel(predictor)
plt.legend()
pyplot.show()
fig.savefig(filegraph+'Revenues_imp.png')

dat[var]= y_new

new_column_revenues= pd.Series(list(dat[var]), name=var, index=list(dat.index))

## =============================================================================
## EQUITY by Total assets
## =============================================================================
predictor = 'DepositsofCustomers'
var = 'Equity'

dat = financial[[var, predictor]].dropna(subset=[predictor])
dat= dat[dat[var].isnull()]
dat2=financial[[var, predictor ]].dropna(subset=[var, predictor])

y=np.array(dat2[var])
x= np.array(dat2[predictor])

f = interpolate.interp1d(x,y, kind='linear')

x_new= np.array(dat[predictor])
intfunc = spi.interp1d(x,y,fill_value="extrapolate")
y_new = intfunc(x_new)

fig = pyplot.figure()
plt.scatter(x,y, color='darkblue', label='Data-Points')
plt.scatter(x_new,y_new, color='lightblue', label='Imputation-Points')
plt.xlabel(var)
plt.ylabel(predictor)
plt.legend()
pyplot.show()
fig.savefig(filegraph+var+'_imp.png')

dat[var]= y_new

new_column_equity= pd.Series(list(dat[var]), name=var, index=list(dat.index))

#new_column_equity = new_column_netincome.replace(-np.inf, np.nan)
#new_column_equity = new_column_netincome.replace(np.inf, np.nan)
#new_column_equity = new_column_netincome.dropna()




# =============================================================================
# NETINCOME predicted by revenues
#===================================================
predictor = 'Revenues'
var = 'NetIncome'

dat = financial[[var, predictor]].dropna(subset=[predictor])
dat= dat[dat[var].isnull()]
dat2=financial[[var, predictor ]].dropna(subset=[var, predictor])

y=np.array(dat2[var])
x= np.array(dat2[predictor])

f = interpolate.interp1d(x,y, kind='linear')

x_new= np.array(dat[predictor])
intfunc = spi.interp1d(x,y,fill_value="extrapolate")
y_new = intfunc(x_new)

fig = pyplot.figure()
plt.scatter(x,y, color='darkblue', label='Data-Points')
plt.scatter(x_new,y_new, color='lightblue', label='Imputation-Points')
plt.xlabel(var)
plt.ylabel(predictor)
plt.legend()
pyplot.show()
fig.savefig(filegraph+'NetIncome_imp.png')

dat[var]= y_new

new_column_netincome= pd.Series(list(dat[var]), name=var, index=list(dat.index))

new_column_netincome = new_column_netincome.replace(-np.inf, np.nan)
new_column_netincome = new_column_netincome.replace(np.inf, np.nan)
new_column_netincome = new_column_netincome.dropna()


# =============================================================================
#  Deposits predicted by branches
# =============================================================================
predictor = 'TotalAssets'
var = 'DepositsofCustomers'

dat = financial[[var, predictor]].dropna(subset=[predictor])
dat= dat[dat[var].isnull()]
dat2=financial[[var, predictor ]].dropna(subset=[var, predictor])

y=np.array(dat2[var])
x= np.array(dat2[predictor])

f = interpolate.interp1d(x,y, kind='linear')

x_new= np.array(dat[predictor])
intfunc = spi.interp1d(x,y,fill_value="extrapolate")
y_new = intfunc(x_new)

fig = pyplot.figure()
plt.scatter(x,y, color='darkblue', label='Data-Points')
plt.scatter(x_new,y_new, color='lightblue', label='Imputation-Points')
plt.xlabel(var)
plt.ylabel(predictor)
plt.legend()
pyplot.show()
fig.savefig(filegraph+var+'_imp.png')

dat[var]= y_new

new_column_deposits= pd.Series(list(dat[var]), name=var, index=list(dat.index))

# =============================================================================
# UPDATE FINANCIAL DATASET
# =============================================================================

financial.update(new_column_revenues)
financial.update(new_column_equity)
financial.update(new_column_netincome)
financial.update(new_column_deposits) 

financial = financial.drop(['RWA'], axis=1)


financial[bank_size_indicators].isnull().sum()


## =============================================================================
## Imputations Kneares neighbours
## =============================================================================
bank_size_indicators_1 = ['Revenues',
       'Equity', 'TotalAssets', 'MarketCapital', 'NetIncome',
       'NumberofCustomer', 'Employees', 'Branches', 'LoansOfCustomers',
       'DepositsofCustomers', 'NumberofOnlineCustomer']


#define number of Neighbour
from sklearn.cluster import KMeans
Sum_of_squared_distances = []
K = range(1,10)
for k in K:
    km = KMeans(n_clusters=k)
    km = km.fit(financial[bank_size_indicators_1])
    Sum_of_squared_distances.append(km.inertia_)

plt.plot(K, Sum_of_squared_distances, 'bx-', color="#00AAE7")
plt.xlabel('k')
plt.ylabel('Sum_of_squared_distances')
plt.show()
fig.savefig(filegraph+'knearest.png')


# Use k = 4 nearest rows which have a feature to fill in each row's
# choose method: euclidean distance

#euclidean distance
k_nearest_data_2= pd.DataFrame(KNN(k=4).fit_transform(financial[bank_size_indicators_1]), columns=bank_size_indicators_1)


#compare means
k_nearest_data_2.mean()
financial.mean()



financial.update(k_nearest_data_2)

financial.to_csv(filepath2+'Finance_normalised_and_KNN_imputed.csv')


